#ifdef __CCE_KT_TEST__
#define __aicore__ 
#else
#define __aicore__ [aicore]
#endif

#include "/home/liuzhenyu/tf/kernel_meta_370_1689234073776669150/kernel_meta/vector_random_buff.h"

extern "C" __global__ __aicore__ void te_assign_d623a1e1b515a45cdc8c9658e58e2860034dbfbd9ab35f92e1415a0fda9d35c1_1__kernel0(__gm__ float* __restrict__ dummy_placeholder, __gm__ float* __restrict__ tensor_val, __gm__ float* __restrict__ res,  __gm__ uint64_t* __restrict__ overflow_status) {
set_atomic_none();
  uint64_t status_overflow[1] = {0};
// "aicore arch: Ascend910A"
  int32_t virtual_data = ((int32_t)get_data_ub_base());
  int32_t logical_core_num = (virtual_data & 65535);
  for (int32_t iter_block_idx = 0; iter_block_idx < (((logical_core_num + ((int32_t)block_num)) - 1) / ((int32_t)block_num)); ++iter_block_idx) {
    int32_t cur_block_idx = ((iter_block_idx * ((int32_t)block_num)) + ((int32_t)block_idx));
    if (cur_block_idx < logical_core_num) {
__ubuf__       float* tensor_val_local_UB = (__ubuf__  float *)get_imm(0);
      copy_gm_to_ubuf(((__ubuf__ float *)tensor_val_local_UB), ((__gm__ float *)tensor_val), 0, 1, 8, 0, 0);
      set_flag(PIPE_MTE2, PIPE_MTE3, EVENT_ID0);
      wait_flag(PIPE_MTE2, PIPE_MTE3, EVENT_ID0);
      copy_ubuf_to_gm(((__gm__ float *)res), ((__ubuf__ float *)tensor_val_local_UB), 0, 1, 8, 0, 0);
      pipe_barrier(PIPE_ALL);
    }
  }
  
  status_overflow[0] = status_overflow[0] | get_status();
  status_overflow[0] = (status_overflow[0] << 32) >> 32;
  uint64_t status_mask = 0x520;
  status_overflow[0] = status_overflow[0] & status_mask;
  if (status_overflow[0]) {
    uint64_t *ptr = (uint64_t *)get_imm(0x43FE0);
    uint64_t buff[4];
    buff[0] = ptr[0];
    buff[1] = ptr[1];
    buff[2] = ptr[2] | status_overflow[0];
    buff[3] = ptr[3];
    
    if (buff[0] == 0) {
      ptr[0] = 0xFFFFFFFFFFFFFFFF;
      ptr[1] = block_idx;
    }
    ptr[2] = buff[2];
    
    __ubuf__ uint8_t* tmp_status = (__ubuf__ uint8_t *)get_imm(0);
    if (buff[2] > 0) {
      *tmp_status = 1;
    } else {
      *tmp_status = 0;
    }
    pipe_barrier(PIPE_ALL);
    copy_ubuf_to_gm(((__gm__ int32_t *)overflow_status), ((__ubuf__ int32_t *)tmp_status), 0, 1, 1, 0, 0);
    pipe_barrier(PIPE_ALL);
  }
  
  int32_t need_random = ((int32_t)get_data_ub_base() >> 16);
  if (need_random > 0) {
    vector_random_buff_kernel0();
  }
  pipe_barrier(PIPE_ALL);

}

